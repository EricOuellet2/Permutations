using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace Permutations
{
    public class PermutationSimpleVar
    {
		public static bool NextPermutation<T>(T[] elements) where T : IComparable<T>
		{
			// More efficient to have a variable instead of accessing a property
			var count = elements.Length;

			// Indicates whether this is the last lexicographic permutation
			var done = true;

			// Go through the array from last to first
			for (var i = count - 1; i > 0; i--)
			{
				var curr = elements[i];

				// Check if the current element is less than the one before it
				if (curr.CompareTo(elements[i - 1]) < 0)
				{
					continue;
				}

				// An element bigger than the one before it has been found,
				// so this isn't the last lexicographic permutation.
				done = false;

				// Save the previous (bigger) element in a variable for more efficiency.
				var prev = elements[i - 1];

				// Have a variable to hold the index of the element to swap
				// with the previous element (the to-swap element would be
				// the smallest element that comes after the previous element
				// and is bigger than the previous element), initializing it
				// as the current index of the current item (curr).
				var currIndex = i;

				// Go through the array from the element after the current one to last
				for (var j = i + 1; j < count; j++)
				{
					// Save into variable for more efficiency
					var tmp = elements[j];

					// Check if tmp suits the "next swap" conditions:
					// Smallest, but bigger than the "prev" element
					if (tmp.CompareTo(curr) < 0 && tmp.CompareTo(prev) > 0)
					{
						curr = tmp;
						currIndex = j;
					}
				}

				// Swap the "prev" with the new "curr" (the swap-with element)
				elements[currIndex] = prev;
				elements[i - 1] = curr;

				// Reverse the order of the tail, in order to reset it's lexicographic order
				for (var j = count - 1; j > i; j--, i++)
				{
					var tmp = elements[j];
					elements[j] = elements[i];
					elements[i] = tmp;
				}

				// Break since we have got the next permutation
				// The reason to have all the logic inside the loop is
				// to prevent the need of an extra variable indicating "i" when
				// the next needed swap is found (moving "i" outside the loop is a
				// bad practice, and isn't very readable, so I preferred not doing
				// that as well).
				break;
			}

			// Return whether this has been the last lexicographic permutation.
			return done;
		}
	}
}
